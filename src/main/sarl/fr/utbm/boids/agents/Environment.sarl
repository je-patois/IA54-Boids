package fr.utbm.boids.agents

import io.sarl.core.InnerContextAccess
import io.sarl.core.Initialize
import io.sarl.core.DefaultContextInteractions
import io.sarl.core.Lifecycle
import fr.utbm.boids.events.StartingSimulation
import java.util.UUID
import fr.utbm.boids.Vector
import fr.utbm.boids.events.StartPosition
import fr.utbm.boids.events.ResultatDeplacement
import io.sarl.util.Scopes
import fr.utbm.boids.events.ValidationDeplacement
import java.util.Map
import java.util.HashMap
import fr.utbm.boids.BoidBody
import io.sarl.lang.core.Address
import fr.utbm.boids.events.DemandeDeplacement
import fr.utbm.boids.gui.fx.EndSimulation
import fr.utbm.boids.events.BoidsReady
import fr.utbm.boids.events.BoidsSideReady
import io.sarl.core.Behaviors
import fr.utbm.boids.gui.BoidsFxViewerController
import fr.utbm.boids.events.Cycle
import fr.utbm.boids.events.BoidInitialized
import io.sarl.core.Logging
import fr.utbm.boids.EnvInfos
import java.util.ArrayList
import fr.utbm.boids.events.PositionModification

agent Environment {
	uses Logging, DefaultContextInteractions, Lifecycle, InnerContextAccess, Behaviors
	
	var boidsList : Map<UUID,BoidBody>	//liste complète des corps de boids
	var boidsGrid : Map<Vector, UUID>
	var boidsAddresses : Map<UUID, Address>
	var boidsUpdated : Integer
	var ctrl : BoidsFxViewerController = null
	var firstTime : boolean
	var spawner : UUID
	var inCycle : Boolean
	var envInfos : EnvInfos
	var FastBoids : ArrayList<UUID>
	var restart : Boolean = false
	// var superBoid : boolean // TODO Un jour peut-être

	on Initialize {
		loggingName = "Environment-" + this.ID
		this.ctrl = occurrence.parameters.get(0) as BoidsFxViewerController
		this.boidsUpdated = 0
		this.boidsList = new HashMap<UUID, BoidBody>
		this.firstTime = true
		this.spawner = occurrence.spawner
		this.inCycle = false
		this.envInfos = new EnvInfos(this.ctrl.mapWidth, this.ctrl.mapHeight)
		this.FastBoids = new ArrayList<UUID>
		info("The Environment is started.")
	}
	
	on StartingSimulation {

		this.boidsGrid = new HashMap<Vector, UUID>
		this.boidsList = new HashMap<UUID, BoidBody>
		this.boidsAddresses = new HashMap<UUID, Address>
		
		info ("ready to start ")
		info('Boids quantity: ' + this.ctrl.boidsQuantity)
		info('Population size: ' + this.ctrl.boidsPopulation)
		for (var i = 0; i < this.ctrl.boidsPopulation; i++) {
			for (var j = 0 ; j < this.ctrl.boidsQuantity; j++){
				spawnInContext(typeof(Boid), innerContext, i + 1, ctrl.boidsSettings.get(i).speed, ctrl.boidsSettings.get(i).mass, ctrl.boidsSettings.get(i).angle, ctrl.boidsSettings.get(i).distance, envInfos)
			}
		}
		//info(this.boidsList)
	}

	on BoidInitialized [occurrence.isInInnerDefaultSpace] {
		if (occurrence.type == "Boid") {
			boidsAddresses.put(occurrence.source.UUID, occurrence.source)
			this.boidsList.put(occurrence.source.UUID, occurrence.body)
			innerContext.defaultSpace.emit(ID, new StartPosition(this.ctrl.obstacles), Scopes.addresses(occurrence.source))
		}
	}

	on BoidsSideReady {
		info("All boids have been created: " + boidsUpdated)
		emit(new BoidsReady)
	}
	
	on PositionModification [!isFromMe] {
		restart = true
		var address = boidsAddresses.get(occurrence.boid)
		this.boidsList.get(occurrence.boid).position.x = occurrence.x
		this.boidsList.get(occurrence.boid).position.y = occurrence.y
		innerContext.defaultSpace.emit(ID, new PositionModification(occurrence.boid, occurrence.x, occurrence.y), Scopes.addresses(address))
	}

	//TODO Si à l'initialisation deux boids spawn au même endroit, il faut relancer un spawn
	on ResultatDeplacement {
		
		var accept = false
		
		occurrence.position = estDansLaCarte(occurrence.position)
		
		synchronized (boidsGrid){
		
			// on regarde si la position est libre 
			if (!this.boidsGrid.containsKey(occurrence.position)) {
				this.boidsGrid.put(occurrence.position, occurrence.source.UUID)
				accept = true
			}
		}
		
		// pour interdire à un boids d'aller dans un obstacle
		/*this.obstacles.forEach[o : Obstacle, index : int |
			if(o.polygon.contains(new Point2D(occurrence.position.x, occurrence.position.y))) {
				// setter accept à false. Au début on le mettrait à true et on le passerait à false seulement si quelque chose empêche le déplacement
			}
		]*/
			
		if (accept) {
			innerContext.defaultSpace.emit(ID, new ValidationDeplacement(occurrence.position), Scopes.addresses(occurrence.source))	
		} else {
			//TODO resolution des problèmes de collision interBoids

			//TODO supprimer acceptation collisions
			innerContext.defaultSpace.emit(ID, new ValidationDeplacement(occurrence.position), Scopes.addresses(occurrence.source))
		}
		
		synchronized (boidsUpdated) {
			boidsUpdated = boidsUpdated + 1 
			FastBoids.add(occurrence.source.UUID)
			if(this.boidsUpdated == this.ctrl.boidsQuantity * this.ctrl.boidsPopulation && this.firstTime == true) {
				//info('boidsUpdated: ' + this.boidsUpdated + ', boidsTotal: ' + this.ctrl.boidsQuantity * this.ctrl.boidsPopulation)
				wake(new BoidsSideReady)
				this.firstTime = false
			}
		}
	}
	
	on Cycle {
		
		synchronized (boidsUpdated) {
			synchronized (boidsGrid) {
				synchronized (FastBoids){
					ctrl.updateGraphics(this.boidsList.values)
					this.boidsUpdated = 0
					boidsAddresses.forEach [ id, address |
						if(this.FastBoids.contains(id)){
							innerContext.defaultSpace.emit(id, new DemandeDeplacement(this.boidsList), Scopes.addresses(address))
							this.FastBoids.remove(id)
						}
					]
					this.boidsGrid = new HashMap<Vector, UUID>
				}
			}
		}
		
		/*if(!inCycle) {
			synchronized (boidsUpdated){
				//info ("demande de rafraichissement : " + this.boidsUpdated)
				// if(this.boidsUpdated == boidsList.size){	//si le nombre de boids ayant update leur coordonnées est égal au nombre de boids vivants, on peut envoyer au Scheduler
				
				
				
				if (this.boidsUpdated >= boidsList.size) {
					inCycle = true
	
					// envoi des nouveaux corps des boids
					ctrl.updateGraphics(this.boidsList.values)
	
					// remise à zéro de la liste des changements
					synchronized (boidsGrid){
						this.boidsGrid = new HashMap<Vector, UUID>
					}
					
					//On se prépare pour la prochaine itération
					this.boidsUpdated = 0
					boidsAddresses.forEach[id, address|
								innerContext.defaultSpace.emit(id, new DemandeDeplacement(this.boidsList), Scopes.addresses(address))
						]
						inCycle = false	
					}	
				}
			} else {
					restart = false
					boidsUpdated = 0
					boidsAddresses.forEach [ id, address |
						innerContext.defaultSpace.emit(id, new DemandeDeplacement(this.boidsList), Scopes.addresses(address))
					]
			}
		}*/
	}

	def estDansLaCarte(v : Vector) : Vector {	//TODO rajouter tests murs ICI / Rename ?
		var positionX = v.getX()
		var positionY = v.getY()
		
		if(positionX > this.ctrl.mapWidth)
			positionX = 1 // peut-être que 0 marche aussi
		if(positionX < 0)
			positionX = this.ctrl.mapWidth - 1 // peut-être que largeur marche aussi
		if(positionY > this.ctrl.mapHeight)
			positionY = 1 // peut-être que 0 marche aussi
		if(positionY < 0)
			positionY = this.ctrl.mapHeight - 1 // peut-être que hauteur marche aussi
		
		var newPosition = new Vector(positionX, positionY)
		return newPosition
	}

	on EndSimulation [!hasMemberAgent] {
		emit(new EndSimulation)
		killMe
	}
	
	// on EndSimulation [hasMemberAgent && occurrence.source.UUID === this.spawner && !isFromMe] {
	on EndSimulation [hasMemberAgent] {
		innerContext.defaultSpace.emit(ID, new EndSimulation)
	}

}