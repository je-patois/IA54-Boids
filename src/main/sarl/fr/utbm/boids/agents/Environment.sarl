package fr.utbm.boids.agents

import io.sarl.core.InnerContextAccess
import io.sarl.core.Initialize
import io.sarl.core.DefaultContextInteractions
import io.sarl.core.Lifecycle
import fr.utbm.boids.events.StartingSimulation
import java.util.UUID
import fr.utbm.boids.util.Vector
import fr.utbm.boids.events.StartPosition
import fr.utbm.boids.events.ResultatDeplacement
import io.sarl.util.Scopes
import fr.utbm.boids.events.ValidationDeplacement
import java.util.Map
import java.util.HashMap
import fr.utbm.boids.BoidBody
import io.sarl.lang.core.Address
import fr.utbm.boids.events.DemandeDeplacement
import fr.utbm.boids.gui.fx.EndSimulation
import fr.utbm.boids.events.BoidsReady
import fr.utbm.boids.events.BoidsSideReady
import io.sarl.core.Behaviors
import fr.utbm.boids.gui.BoidsFxViewerController
import fr.utbm.boids.events.Cycle
import fr.utbm.boids.events.BoidInitialized
import io.sarl.core.Logging
import fr.utbm.boids.EnvInfos
import fr.utbm.boids.events.PositionModification

agent Environment {
	uses Logging, DefaultContextInteractions, Lifecycle, InnerContextAccess, Behaviors
	
	var boidsList : Map<UUID,BoidBody>	//liste complète des corps de boids
	var boidsGrid : Map<Vector, UUID>
	var boidsAddresses : Map<UUID, Address>
	var boidsUpdated : Integer
	var ctrl : BoidsFxViewerController = null
	var firstTime : boolean
	var spawner : UUID
	var inCycle : Boolean
	var envInfos : EnvInfos
	var restart : Boolean = false

	on Initialize {
		loggingName = "Environment-" + this.ID
		this.ctrl = occurrence.parameters.get(0) as BoidsFxViewerController
		this.boidsUpdated = 0
		this.boidsList = new HashMap<UUID, BoidBody>
		this.firstTime = true
		this.spawner = occurrence.spawner
		this.inCycle = false
		this.envInfos = new EnvInfos(this.ctrl.mapWidth, this.ctrl.mapHeight)
		info("The Environment is started.")
	}
	
	on StartingSimulation {

		this.boidsGrid = new HashMap<Vector, UUID>
		this.boidsList = new HashMap<UUID, BoidBody>
		this.boidsAddresses = new HashMap<UUID, Address>
		
		info ("ready to start ")
		info('Boids quantity: ' + this.ctrl.boidsQuantity)
		info('Population size: ' + this.ctrl.boidsPopulation)
		for (var i = 0; i < this.ctrl.boidsPopulation; i++) {
			for (var j = 0 ; j < this.ctrl.boidsQuantity; j++){
				spawnInContext(typeof(Boid), innerContext, i + 1, ctrl.boidsSettings.get(i).speed, ctrl.boidsSettings.get(i).mass, ctrl.boidsSettings.get(i).angle, ctrl.boidsSettings.get(i).distance, envInfos)
			}
		}
	}

	on BoidInitialized [occurrence.isInInnerDefaultSpace] {
		if (occurrence.type == "Boid") {
			boidsAddresses.put(occurrence.source.UUID, occurrence.source)
			this.boidsList.put(occurrence.source.UUID, occurrence.body)
			innerContext.defaultSpace.emit(ID, new StartPosition(this.ctrl.obstacles), Scopes.addresses(occurrence.source))
		}
	}

	on BoidsSideReady {
		info("All boids have been created: " + boidsUpdated)
		emit(new BoidsReady)
	}
	
	on PositionModification [!isFromMe] {
		restart = true
		this.boidsList.get(occurrence.boid).position.x = occurrence.x
		this.boidsList.get(occurrence.boid).position.y = occurrence.y
	}

	on ResultatDeplacement {
		
		var accept = false
		
		occurrence.position = estDansLaCarte(occurrence.position)
		
		synchronized (boidsGrid) {
		
			// on regarde si la position est libre 
			if (!this.boidsGrid.containsKey(occurrence.position)) {
				this.boidsGrid.put(occurrence.position, occurrence.source.UUID)
				accept = true
			}
		}
		
			
		if (accept) {
			innerContext.defaultSpace.emit(ID, new ValidationDeplacement(occurrence.position), Scopes.addresses(occurrence.source))	
		} else {
			if (this.firstTime == true) {
				innerContext.defaultSpace.emit(ID, new StartPosition(this.ctrl.obstacles), Scopes.addresses(occurrence.source))
			}else{
				innerContext.defaultSpace.emit(ID, new DemandeDeplacement(this.boidsList, this.ctrl.obstacles),Scopes.addresses(occurrence.source))
			}
		}
		
		synchronized (boidsUpdated) {
			if (accept){
				boidsUpdated = boidsUpdated + 1
			}
			if(this.boidsUpdated == this.ctrl.boidsQuantity * this.ctrl.boidsPopulation && this.firstTime == true) {
				wake(new BoidsSideReady)
				this.firstTime = false
			}
		}
	}
	
	on Cycle{
		if(!inCycle) {
			if(!restart) {
				synchronized (boidsUpdated){
					 if(this.boidsUpdated == boidsList.size){	//si le nombre de boids ayant update leur coordonnées est égal au nombre de boids vivants, on peut envoyer au Scheduler
						inCycle = true
						// envoi des nouveaux corps des boids
						ctrl.updateGraphics(this.boidsList.values)
		
						// remise à zéro de la liste des changements
						synchronized (boidsGrid){
							this.boidsGrid = new HashMap<Vector, UUID>
						}
						
						//On se prépare pour la prochaine itération
						this.boidsUpdated = 0
						boidsAddresses.forEach[id, address|
								innerContext.defaultSpace.emit(id, new DemandeDeplacement(this.boidsList, this.ctrl.obstacles), Scopes.addresses(address))
						]
						inCycle = false	
					}	
				}
			} else {
					restart = false
					boidsUpdated = 0
					boidsAddresses.forEach [ id, address |
						innerContext.defaultSpace.emit(id, new DemandeDeplacement(this.boidsList, this.ctrl.obstacles), Scopes.addresses(address))
					]
			}
		}
	}

	def estDansLaCarte(v : Vector) : Vector {
		var positionX = v.getX()
		var positionY = v.getY()
		
		if(positionX > this.ctrl.mapWidth)
			positionX = 1 
		if(positionX < 0)
			positionX = this.ctrl.mapWidth - 1 
		if(positionY > this.ctrl.mapHeight)
			positionY = 1 
		if(positionY < 0)
			positionY = this.ctrl.mapHeight - 1 
		
		var newPosition = new Vector(positionX, positionY)
		return newPosition
	}

	on EndSimulation [!hasMemberAgent] {
		emit(new EndSimulation)
		killMe
	}
	
	on EndSimulation [hasMemberAgent] {
		innerContext.defaultSpace.emit(ID, new EndSimulation)
	}

}