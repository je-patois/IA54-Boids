package fr.utbm.boids.agents

import io.sarl.core.Initialize
import io.sarl.core.Logging
import io.sarl.core.DefaultContextInteractions
import java.util.Collection
import fr.utbm.boids.events.IsStarted
import fr.utbm.boids.events.DemandeDeplacement
import fr.utbm.boids.events.StartPosition
import fr.utbm.boids.events.ResultatDeplacement
import fr.utbm.boids.Vector
import java.util.Random
import fr.utbm.boids.events.ValidationDeplacement
import fr.utbm.boids.BoidBody
import fr.utbm.boids.events.InitBoidBody
import fr.utbm.boids.events.BoidBodyInitialized
import fr.utbm.boids.environment.Obstacle
import java.util.concurrent.atomic.AtomicBoolean
import java.util.concurrent.atomic.AtomicInteger
import javafx.geometry.Point2D
import io.sarl.core.Lifecycle
import java.util.UUID
import fr.utbm.boids.gui.fx.EndSimulation
import io.sarl.core.Schedules
import java.util.Map
import io.sarl.core.Destroy

agent Boid {
	uses Logging, DefaultContextInteractions, Lifecycle, Schedules

	var body : BoidBody
	var parentAgent : UUID
	
	/*
	 * gestion des évènements
	 */
	 
	on Initialize {
		loggingName = "Boid-" + this.ID
		info("A Boid agent was started.")
		parentAgent = occurrence.spawner
		task('say-started').every(1000) [emit(new IsStarted("Boid"))]
	}
	
	on InitBoidBody {
		task('say-started').cancel
		//this.body = occurrence.body
		//this.body = new BoidBody(occurrence.body)
		//info(occurrence.body.groupe)
		//info(occurrence.body.groupeVitesseMax)
		//info(occurrence.body.masse)
		//info(occurrence.body.angleVisibilite)
		//info(occurrence.body.distanceVisibilite)
		this.body = new BoidBody(occurrence.body.groupe, occurrence.body.groupeVitesseMax, occurrence.body.masse, occurrence.body.angleVisibilite, occurrence.body.distanceVisibilite)
		info('Mon body est initialisé!')
		emit(new BoidBodyInitialized())
	}
	
	on StartPosition {
		var validPosition : AtomicBoolean = new AtomicBoolean(true)
		var maPosition : Vector
		var x : AtomicInteger = new AtomicInteger(0)
		var y : AtomicInteger = new AtomicInteger(0)		
		do {
			validPosition.set(true)
			var rnd = new Random()
			x.set(rnd.nextInt(occurrence.largeur) + 1)
			y.set(rnd.nextInt(occurrence.hauteur) + 1)
			occurrence.obstacles.forEach[o : Obstacle, index : int | 
				if(o.getPolygon().contains(new Point2D(x.get(), y.get()))) {
					validPosition.set(false)
				}
			]
		} while(validPosition.get() == false)
		
		info("X, Y \n" + x + " " + y)
		maPosition = new Vector(x.get(), y.get())
		emit(new ResultatDeplacement(maPosition))
	}

	// Si le déplacement est validé, on enregistre la nouvelle position du Boids, ainsi que sa nouvelle vitesse
	on ValidationDeplacement {
		this.body.position = occurrence.position
		this.body.vitesse = this.body.newVitesse
		info("Validation de la position")
	}
	
	@SuppressWarnings("equals_with_null")
	on DemandeDeplacement {
		
		/* 
		 * on récupère la liste des autres boids
		 */
		var otherBoids = occurrence.otherBoids
		var forceTot : Vector

		forceTot = new Vector(0, 0)
		
		/* 		 / \
		 *		/ !	\	 On suppose que le Boids que je suis a été supprimé de la liste
		 *	   /_____\
		 */	   
		 info("EST CE QUE L'ON PASSE AU MOINS ICI? PARLE MOIIIIIIIIIIIIIIIIIIII")
		if (otherBoids != null) {
			info("ON PREND EN COMPTE LES AUTRES BOIDS MON GARS")
			//TODO ici rajouter vitesse de départ du boids
			
			//TODO rajouter dans chaque focntion une vérification que l'on ne se prend pas soi meme en compte pour les calculs
			//on applique la séparation 
			forceTot.plus(separation(otherBoids))
			
			//on applique la cohésion
			forceTot.plus(cohesion(otherBoids))
			
			//on applique l'alignement
			forceTot.plus(alignement(otherBoids))

			//on applique la répulsion
			forceTot.plus(repulsion(otherBoids))
			
			//on applique la force résultant de la détection des obstacles
		 
			// TODO appliquer force obstacle
		}
		
		//on renvoie la nouvelle position du Boids
		//info(forceTot + " ceci est la force totale a appliquer !!!!!!!!!!")
		emit(new ResultatDeplacement(appliquerForce(forceTot)))
	 
	}
	
	/*
	 * fonction qui permet de déterminer si le boids en question est visible dans notre perception
	 */
	 
	 def visible (b : BoidBody) : boolean{
	 	
	 	var tmp : Vector
	 	var tmp2 : Vector
	 	
	 	tmp = new Vector(b.position)
	 	tmp.moins(this.body.position)
	 	
	 	// Si le boids est trop loin, on ne le voit pas 
	 	if (tmp.length() > this.body.distanceVisibilite){
	 		return false
	 	}
	 	
	 	tmp2 = new Vector(this.body.vitesse)
	 	
	 	tmp2.normaliser()
	 	//tmp2.fois(this.body.groupeVitesseMax)			//TODO m'expliquer pourquoi normaliser avait été changé et pourquoi on voulait faire une multiplication par la vitesseMax
	 	
	 	// pas dans le code du prof mais pourtant le vecteur doit l'être pour que la formule marche et ça me parraît pas être "logique" tmp soit déjà normaliser
	 	tmp.normaliser()
	 	//tmp.fois(this.body.groupeVitesseMax)
	 	
	 	if (tmp2.point(tmp) < this.body.angleVisibilite) {
	 		return false
	 	}
	 	
	 	return true
	 }
	 
	
	/* 
	 * Création des fonctions comportementales du Boids
	 */
	 
	//TODO test si non utilisation du test du groupe à une influence
	@SuppressWarnings("equals_with_null")
	def separation(otherBoids : Map<UUID, BoidBody>) : Vector {

		var force : Vector
		var tmp : Vector
		var len : double

		force = new Vector(0, 0)
		tmp = new Vector(0, 0)

		/*otherBoids.forEach [ id, boid |
			if (boid != null && boid.groupe == this.body.groupe && visible(boid) && id != this.ID) {
				tmp.setXY(this.body.position)
				tmp.moins(boid.position)
				len = tmp.length()
				tmp.fois(1 / (len * len))
				force.plus(tmp)
			}
		 * ]
		 */
		 
		for (elem : otherBoids.entrySet) {
			if (elem.key != null && elem.value.groupe == this.body.groupe && /*visible(elem.value) && */elem.key != this.ID) {
				tmp.setXY(this.body.position)
				tmp.moins(elem.value.position)
				len = tmp.length()
				tmp.fois(1 / (len * len))
				force.plus(tmp)
			}
		}
		
/* 
		for (boid : otherBoids) {
			if (boid != null && boid.groupe == this.body.groupe && visible(boid)) {
				tmp.setXY(this.body.position)
				tmp.moins(boid.position)
				len = tmp.length()
				tmp.fois(1 / (len * len))
				force.plus(tmp)
			}
		}
*/
		return force

	}

	@SuppressWarnings("equals_with_null")
	def cohesion(otherBoids : Map<UUID, BoidBody>) : Vector {
		
		var nbTot = 0 
		var force : Vector 
		
		force = new Vector(0,0)
		
		/*otherBoids.forEach [ id, boid |
			if (boid != null && boid.groupe == this.body.groupe && visible(boid)) {
				nbTot++
				force.plus(boid.position)
			}
		 * ]
		 */
		 
		for (elem : otherBoids.entrySet) {
			if (elem.key != null && elem.value.groupe == this.body.groupe/* && visible(elem.value)*/) {
				nbTot++
				force.plus(elem.value.position)
			}
		}
		
		/*
		for (boid : otherBoids) {
			if (boid != null && boid.groupe == this.body.groupe && visible(boid)){
				nbTot++
				force.plus(boid.position)
			}
		}*/
		
		if (nbTot > 0){
			force.fois(1/nbTot)
			force.moins(this.body.position)
		}
		
		return force
	}
	
	

	@SuppressWarnings("equals_with_null")
	def alignement(otherBoids : Map<UUID, BoidBody>) : Vector {
		
		var nbTot = 0 
		var force : Vector
		var tmp : Vector
		
		force = new Vector(0,0)
		tmp = new Vector(0,0)
		
		/*otherBoids.forEach [ id, boid |
			if (boid != null && boid.groupe == this.body.groupe && visible(boid)) {
				nbTot++
				tmp.setXY(boid.vitesse)
				tmp.fois(1 / tmp.length)
				force.plus(tmp)
			}
		]*/

		for (elem : otherBoids.entrySet) {
			if (elem.key != null && elem.value.groupe == this.body.groupe/*&& visible(elem.value)*/) {
				nbTot++
				tmp.setXY(elem.value.position)
				tmp.fois(1 / tmp.length)
				force.plus(tmp)
			}
		}
		info(force + " ceci est la force a appliquer !!!!!!!!!!")
		/*
		for (boid : otherBoids){
			if (boid != null && boid.groupe == this.body.groupe && visible(boid)) {
				nbTot++
				tmp.setXY(boid.vitesse)
				tmp.fois(1/tmp.length)
				force.plus(tmp)
			}
		}*/
		
		if (nbTot > 0) {
			force.fois(1/nbTot)	
		}
		
		return force
		
	}

	@SuppressWarnings("equals_with_null")
	def repulsion(otherBoids : Map<UUID, BoidBody>) : Vector {
		
		var force : Vector
		var tmp : Vector
		var len : double
		
		force = new Vector(0,0)
		tmp = new Vector(0,0)
		
		/*otherBoids.forEach [ id, boid |
			if (boid != null && boid.groupe != this.body.groupe && visible(boid)) {
				tmp.setXY(this.body.position)
				tmp.moins(boid.position)
				len = tmp.length
				tmp.fois(1 / (len * len))
				force.plus(tmp)
			}
		]*/

		for (elem : otherBoids.entrySet) {
			if (elem.key != null && elem.value.groupe != this.body.groupe /*&& visible(elem.value)*/) {
				tmp.setXY(this.body.position)
				tmp.moins(elem.value.position)
				len = tmp.length
				tmp.fois(1 / (len * len))
				force.plus(tmp)
			}
		}
		
		/*
		for (boid : otherBoids){
			if (boid != null && boid.groupe != this.body.groupe && visible(boid)){
				tmp.setXY(this.body.position)
				tmp.moins(boid.position)
				len = tmp.length
				tmp.fois(1/(len*len))
				force.plus(tmp)
			}
		}*/
		
		return force
	}
	
	
	// retourne la position du boid après l'application de la force, stoque en mémoire la nouvelle vitesse du Boids
	def appliquerForce(force : Vector) : Vector {

		// f = ma => a =f/m

		var newPosition : Vector		
		var acceleration : Vector
		
		acceleration = new Vector(force)
		acceleration.fois(1/this.body.masse)
		info("acceleration : " + acceleration)

		//DEFINITION EN DUR ICI
		this.body.vitesse = new Vector(5, 5)
		info("bodyVitesse : " + this.body.vitesse)
		
		this.body.newVitesse = new Vector(this.body.vitesse)
		this.body.newVitesse.plus(acceleration)
		//WAT ON ADDITIONNE VITESSE ET ACCELERATION???
		
		info("nouvelle vitesse : " + this.body.newVitesse)
		
		//bornage de la vitesse
		if (this.body.newVitesse.length > this.body.groupeVitesseMax){
			this.body.newVitesse.normaliser()
			this.body.newVitesse.fois(this.body.groupeVitesseMax)
		}
		
		//maj position
		info(this.body.position.x)
		info(this.body.position.y)
		newPosition = new Vector(this.body.position)
		newPosition.plus(this.body.newVitesse)
		info(newPosition)
		return newPosition
	}
	
	on EndSimulation [isFrom(this.parentAgent)] {
		// info("Boid kill")
		emit(new EndSimulation) [it.UUID == this.parentAgent]
		killMe
	}
	
	/*on Destroy {
		emit(new EndSimulation)[it.UUID == this.parentAgent]
	}*/
}
