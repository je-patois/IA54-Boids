package fr.utbm.boids.gui

import fr.utbm.boids.gui.fx.FxViewerController
import javafx.fxml.FXML
import fr.utbm.boids.events.ConfigureSimulation
import javafx.scene.control.Label
import javafx.scene.control.ScrollBar
import javafx.scene.control.Button
import javafx.scene.Group
import javafx.scene.layout.Pane
import javafx.application.Platform
import javafx.scene.shape.Polygon
import fr.utbm.boids.util.Coordinates
import fr.utbm.boids.util.LineTool
import com.google.common.util.concurrent.AtomicDouble
import java.util.ArrayList
import java.util.List
import fr.utbm.boids.environment.Obstacle
import fr.utbm.boids.BoidBody
import java.util.Collection
import javafx.scene.shape.Circle
import javafx.scene.paint.Color
import fr.utbm.boids.Configuration
import javafx.scene.control.ToggleButton
import javafx.scene.layout.Background
import javafx.scene.layout.BackgroundFill
import javafx.scene.layout.CornerRadii
import javafx.geometry.Insets
import javafx.scene.effect.Glow
import javafx.scene.input.MouseEvent
import javafx.^event.EventHandler
import javafx.scene.shape.Rectangle
import fr.utbm.boids.events.Pause
import fr.utbm.boids.events.Resume
import javafx.scene.shape.Arc
import javafx.scene.shape.ArcType
import javafx.scene.transform.Rotate
import javafx.scene.transform.Affine
import javafx.scene.control.TextField
import javafx.scene.shape.Line
import java.util.concurrent.TimeUnit

class BoidsFxViewerController extends FxViewerController  {

	var launched = false
	var mapCreated = false

	@FXML var main_pane : Pane
	@FXML var boids_group : Group // Groupe contenant les boids
	@FXML var UI_pane : Pane // Pane contenant l'UI
	@FXML var obstacle_group : Group // Groupe contenant les obstacles
	
	@FXML var toggle_night_mode : ToggleButton
	@FXML var toggle_perception : ToggleButton
	@FXML var start_button : Button
	@FXML var night_mode_indicator : Circle
	@FXML var perception_indicator : Circle

	// Titres
	@FXML var boids_quantity_label : Label
	@FXML var map_selection_label : Label
	@FXML var boids_population_label : Label
	@FXML var boids_vision_label : Label
	@FXML var boids_distance_deplacement_label : Label

	// Input
	@FXML var boids_quantity_input : ScrollBar
	@FXML var map_selection_input : ScrollBar
	@FXML var boids_population_input : TextField
	@FXML var boids_vision_input : ScrollBar
	@FXML var boids_distance_deplacement_input : ScrollBar

	// Valeurs
	@FXML var boids_quantity_display : Label
	@FXML var map_selection_display : Label
	@FXML var boids_vision_display : Label
	@FXML var boids_distance_deplacement_display : Label
	
	@FXML var boids_quantity_min : Label
	@FXML var boids_quantity_max : Label
	@FXML var map_min : Label
	@FXML var map_max : Label
	@FXML var boids_vision_min : Label
	@FXML var boids_vision_max : Label
	@FXML var boids_distance_deplacement_min : Label
	@FXML var boids_distance_deplacement_max : Label
	
	@FXML var pause_button : Rectangle
	@FXML var resume_button : Polygon
	@FXML var boid_group : Label
	@FXML var boid_vitesse : Label
	@FXML var boid_new_vitesse : Label
	@FXML var boid_group_vitesse : Label
	@FXML var boid_angle : Label
	@FXML var boid_distance : Label
	@FXML var boid_masse : Label
	@FXML var hide_infos : Button
	@FXML var boids_infos_pane : Pane
		
	@FXML var boids_population_line : Line
	@FXML var increment_boids_population : Label
	@FXML var decrement_boids_population : Label
	@FXML var boids_population_increment_circle : Circle
	@FXML var boids_population_decrement_circle : Circle

	var polygons : List<Polygon>
	var polygonsCoordinates : List<List<Coordinates>>
	var obstacles : List<Obstacle> = new ArrayList()
	var nightMode : Boolean = true
	var togglePerception : Boolean = true

	def getBoidsQuantity() : int {
		boids_quantity_input.value as int
	}
	
	def getMapSelection() : int {
		map_selection_input.value as int
	}
	
	def getBoidsPopulation() : int {
		//boids_population_input.value as int
		Integer.parseInt(boids_population_input.text)
	}
	
	def getBoidsVision() : int {
		boids_vision_input.value as int
	}
	
	def getMapWidth() : int {
		main_pane.width as int
	}
	
	def getMapHeight() : int {
		main_pane.height as int
	}
	
	def getObstacles() : List<Obstacle> {
		obstacles
	}
	
	def getBoidsDistanceDeplacement() : int {
		boids_distance_deplacement_input.value as int
	}
 
	@FXML protected def startSimu() : void {
		if(boids_population_input.text != '' && outputQuality(boids_population_input.text)) { 
			var ^event = new ConfigureSimulation(this.mapSelection, this.boidsQuantity, this.boidsPopulation, this.boidsVision)
			if (!launched) {
				startAgentApplication() [
					emitToAgents(^event)
				]
				launched = true
				mapCreated = false
				toggleUIState()
				toggleMenuUIVisibility()
				toggleSimuUIVisibility()
				toggle_night_mode.background = new Background(new BackgroundFill(Color.TRANSPARENT, CornerRadii.EMPTY, Insets.EMPTY))
				if(nightMode) {
					toggle_night_mode.textFill = Color.rgb(191, 191, 191, 0.3)
				} else {
					toggle_night_mode.textFill = Color.rgb(0, 0, 0, 0.3)
				}		
			} else {
				emitToAgents(^event)
			}
		}
	}
	
	def buildMap(map : int) : List<Obstacle> {

		pause_button.visible = true

		if(map == 1) {
			return new ArrayList()
		}
		else if (map == 2) {
			this.polygons = new ArrayList()
			this.polygonsCoordinates = new ArrayList()
			this.obstacles = new ArrayList()
			this.polygons.add(new Polygon(250.0, 200.0, 365.0, 250.0, 400.0, 300.0, 325.0, 400.0, 205.0, 225.0))
			this.polygons.add(new Polygon(605.0, 80.0, 675.0, 65.0, 680.0, 125.0, 650.0, 220.0, 630.0, 250.0, 660.0, 130.0,
					665.0, 75.0, 615.0, 95.0, 560.0, 240.0, 560.0, 205.0, 605.0, 80.0))
			this.polygons.add(new Polygon(450.0, 450.0, 575.0, 500.0, 575.0, 420.0, 700.0, 500.0, 590.0, 450.0, 590.0, 520.0))
			this.polygons.forEach[p : Polygon |
				this.polygonsCoordinates.add(this.generateCoordinates(p))
				p.setFill(Color.GRAY)
				p.setStroke(Color.TRANSPARENT)
				p.setStrokeWidth(20)
			]

			var command = new Runnable() {
				@Override
				def run() {
					polygons.forEach [ p : Polygon |
						obstacle_group.getChildren().add(0, p)
					]
					/*System.out.println('LE TEST')
					var testcircle = new Circle(395, 310, 1)
					//System.out.println(polygons.get(0).contains(new Point2D(testcircle.centerX, testcircle.centerY)))
					 * obstacle_group.getChildren().add(0, testcircle)
					 */
					 // TODO ici'a fai
					/*var boidElement : Polygon = new Polygon(200, 200 - 7.5, 200 + 5, 200 + 7.5, 200 - 5, 200 + 7.5)
					boidElement.rotate = Math.toDegrees(Math.atan(1/8))
					obstacle_group.getChildren().add(0, boidElement)*/
				}
		};

			if (Platform.isFxApplicationThread()) {
				command.run();
				this.generateObstacles()
				// this.obstacles.forEach[o : Obstacle|System.out.println(o.toString())]
				return this.obstacles
			} else {
				Platform.runLater(command);
				this.generateObstacles()
				// this.obstacles.forEach[o : Obstacle|System.out.println(o.toString())]
				return this.obstacles
			}
		}
	}
	
	def generateCoordinates(p : Polygon) : List<Coordinates> {
		var abscissa : AtomicDouble = new AtomicDouble();
		var coordinates : List<Coordinates> = new ArrayList()
		p.getPoints.forEach [ ordered : Double, index : int |
			if (index % 2 == 0) {
				abscissa.set(ordered)
			} else {
				coordinates.add(new Coordinates(abscissa.get(), ordered.doubleValue()))
			}
		]
		return coordinates
	}
	
	def generateObstacles() : void {
		this.polygonsCoordinates.forEach [p : List<Coordinates>, currentItem : int |
			var lines : List<LineTool> = new ArrayList()
			p.forEach[c : Coordinates, index : int |
				if(index != 0) {
					var line : LineTool = new LineTool(p.get(index - 1), c)
					line.computeLineEquation()
					lines.add(line)
				}
			]
			var line : LineTool = new LineTool(p.last, p.get(0))
			line.computeLineEquation()
			lines.add(line)
			this.obstacles.add(new Obstacle(lines, this.polygons.get(currentItem)))
		]
		
	}
	
	def updateGraphics(list: Collection<BoidBody>) : void {
		var command = new Runnable() {
			@Override
			def run() {
				boids_group.getChildren().clear()
				for (boid : list){
					var boidElement : Polygon = new Polygon(boid.position.x, getMapHeight - boid.position.y - 7.5, boid.position.x + 5, getMapHeight - boid.position.y + 7.5, boid.position.x - 5, getMapHeight -  boid.position.y + 7.5)
					var angleRotation = Math.toDegrees(Math.atan(boid.vitesse.x / boid.vitesse.y))
					if (angleRotation < 0){
						angleRotation += 180
					}
					if (boid.vitesse.x < 0 ){
						if (boid.vitesse.y < 0 ){
							angleRotation -= 180
						}else{
							angleRotation += 180
						}
					 }
					
					boidElement.rotate = angleRotation
					boidElement.setFill(Configuration::COLOR_FAMILY.get(boid.groupe))
					
					boidElement.setOnMousePressed(new EventHandler<MouseEvent>() {
						def handle(^event : MouseEvent) {
							boid_group.text = 'Groupe: ' + boid.groupe
							boid_vitesse.text = 'Vitesse: (' + String.format("%.3f", boid.vitesse.x) + ', ' + String.format("%.3f",boid.vitesse.y) + ')' 
							boid_group_vitesse.text = 'Vitesse max. groupe: ' + boid.groupeVitesseMax
							boid_masse.text = 'Masse: ' + boid.masse
							boid_angle.text = 'Angle: ' + boid.angleVisibilite
							boid_distance.text = 'Distance percep.: ' + boid.distanceVisibilite
							boid_new_vitesse.text = 'Nouvelle vitesse: (' + boid.newVitesse.x + ', ' + boid.newVitesse.y + ')'
							showInfosVisibility()
						}
					}); 
					
					if(togglePerception) {
						var perceptionArc = new Arc()
						perceptionArc.setCenterX(boid.position.x);
						perceptionArc.setCenterY(getMapHeight - boid.position.y);
						perceptionArc.setRadiusX(Double.parseDouble(boids_distance_deplacement_display.text));
						perceptionArc.setRadiusY(Double.parseDouble(boids_distance_deplacement_display.text));
						perceptionArc.setStartAngle(90 - angleRotation - Double.parseDouble(boids_vision_display.text))
						perceptionArc.setLength(Double.parseDouble(boids_vision_display.text) * 2 );
						perceptionArc.setType(ArcType.ROUND);
						if(nightMode) {
							perceptionArc.fill = Color.rgb(255, 245, 112, 0.2)
						} else {
							perceptionArc.fill = Color.rgb(255, 245, 112, 0.8)
						}
						boids_group.getChildren().add(0, boidElement)
						boids_group.getChildren.add(0, perceptionArc)
					} else {
						boids_group.getChildren.add(0, boidElement)
					}
					
				}
			}
		}
		
		if (Platform.isFxApplicationThread()) {
			command.run();
		} else {
			Platform.runLater(command);
		}	
	}

	@FXML protected def actionBoidsQuantityDisplay() : void {
		boids_quantity_input.valueProperty().addListener [
			boids_quantity_display.setText(String.format("%.0f", boids_quantity_input.getValue()));
		];
	}

	@FXML protected def actionMapSelectionDisplay() : void {
		map_selection_input.valueProperty().addListener [
			map_selection_display.setText(String.format("%.0f", map_selection_input.getValue()));
		];
	}

	@FXML protected def actionBoidsVisionDisplay() : void {
		boids_vision_input.valueProperty().addListener [
			boids_vision_display.setText(String.format("%.0f", boids_vision_input.getValue()));
		];
	}

	@FXML protected def actionBoidsDistanceDeplacementDisplay() : void {
		boids_distance_deplacement_input.valueProperty().addListener [
			boids_distance_deplacement_display.setText(String.format("%.0f", boids_distance_deplacement_input.getValue()));
		];
	}
	
	@FXML protected def resetBoidsPopulation() : void {
		boids_population_input.text = ''
	}
	
	@FXML protected def updateBoidsPopulation() : void {
		if(boids_population_input.text != '') {
			if (outputQuality(boids_population_input.text)) {
				var currentValue : int = Integer.parseInt(boids_population_input.text)
				if (currentValue >= 10) {
					boids_population_input.text = '' + 10
				} else if (currentValue <= 1) {
					boids_population_input.text = '' + 1
				}
			}
		}
	}
	
	@FXML protected def incrementBoidsPopulation() : void {
		if(boids_population_input.text != '' && outputQuality(boids_population_input.text)) {
			var currentValue : int = Integer.parseInt(boids_population_input.text)
			if(currentValue >= 10) {
				boids_population_input.text = '' + 10
			} else {
				boids_population_input.text = '' + (currentValue + 1)
			}
		} else {
			boids_population_input.text = '' + 1
		}
	}
	
	@FXML protected def decrementBoidsPopulation() : void {
		if(boids_population_input.text != '' && outputQuality(boids_population_input.text)) {
			var currentValue : int = Integer.parseInt(boids_population_input.text)
			if(currentValue <= 1) {
				boids_population_input.text = '' + 1
			} else {
				boids_population_input.text = '' + (currentValue - 1)
			}
		} else {
			boids_population_input.text = '' + 1
		}
	}
	
	@FXML protected def toggleMode() : void {
		if(nightMode) {
			nightMode = false
			night_mode_indicator.fill = Color.TRANSPARENT
			night_mode_indicator.stroke = Color.rgb(0, 0, 0, 0.3)
			perception_indicator.stroke = Color.rgb(0, 0, 0, 0.3)
			var normalTextColor : Color = Color.BLACK
			main_pane.background = new Background(new BackgroundFill(Color.rgb(244, 244, 244), CornerRadii.EMPTY, Insets.EMPTY))
			boids_quantity_label.textFill = normalTextColor; boids_quantity_display.textFill = normalTextColor; boids_quantity_min.textFill = normalTextColor; boids_quantity_max.textFill = normalTextColor
			map_selection_label.textFill = normalTextColor;	map_selection_display.textFill = normalTextColor; map_min.textFill = normalTextColor; map_max.textFill = normalTextColor
			boids_population_label.textFill = normalTextColor; decrement_boids_population.textFill = normalTextColor; increment_boids_population.textFill = normalTextColor; boids_population_decrement_circle.stroke = normalTextColor; boids_population_increment_circle.stroke = normalTextColor; boids_population_line.stroke = normalTextColor; boids_population_input.style = '-fx-text-fill: rgb(0, 0, 0); -fx-background-color: transparent'
			boids_vision_label.textFill = normalTextColor; boids_vision_display.textFill = normalTextColor;	boids_vision_min.textFill = normalTextColor; boids_vision_max.textFill = normalTextColor
			
			boids_distance_deplacement_label.textFill = normalTextColor;
			boids_distance_deplacement_display.textFill = normalTextColor;
			boids_distance_deplacement_min.textFill = normalTextColor;
			boids_distance_deplacement_max.textFill = normalTextColor
			
			boid_group.textFill = Color.rgb(0, 0, 0, 0.7)
			boid_vitesse.textFill = Color.rgb(0, 0, 0, 0.7)
			boid_group_vitesse.textFill = Color.rgb(0, 0, 0, 0.7)
			boid_masse.textFill = Color.rgb(0, 0, 0, 0.7)
			boid_angle.textFill = Color.rgb(0, 0, 0, 0.7)
			boid_distance.textFill = Color.rgb(0, 0, 0, 0.7)
			boid_new_vitesse.textFill = Color.rgb(0, 0, 0, 0.7)
			toggle_night_mode.textFill = Color.rgb(0, 0, 0, 0.3)
			toggle_perception.textFill = Color.rgb(0, 0, 0, 0.3)
			hide_infos.textFill = Color.rgb(0, 0, 0, 0.3)
			start_button.textFill = normalTextColor
		} else {
			nightMode = true
			night_mode_indicator.fill = Color.rgb(0, 204, 99)
			night_mode_indicator.stroke = Color.rgb(184, 193, 207, 0.3)
			perception_indicator.stroke = Color.rgb(184, 193, 207, 0.3)
			var nightTextColor : Color = Color.rgb(191, 191, 191)
			main_pane.background = new Background(new BackgroundFill(Color.rgb(34, 34, 34), CornerRadii.EMPTY, Insets.EMPTY))
			boids_quantity_label.textFill = nightTextColor;	boids_quantity_display.textFill = nightTextColor; boids_quantity_min.textFill = nightTextColor;	boids_quantity_max.textFill = nightTextColor
			map_selection_label.textFill = nightTextColor; map_selection_display.textFill = nightTextColor;	map_min.textFill = nightTextColor;	map_max.textFill = nightTextColor
			boids_population_label.textFill = nightTextColor; decrement_boids_population.textFill = nightTextColor; increment_boids_population.textFill = nightTextColor; boids_population_decrement_circle.stroke = nightTextColor; boids_population_increment_circle.stroke = nightTextColor;	boids_population_line.stroke = nightTextColor;	boids_population_input.style = '-fx-text-fill: rgb(191, 191, 191); -fx-background-color: transparent'
			boids_vision_label.textFill = nightTextColor; boids_vision_display.textFill = nightTextColor; boids_vision_min.textFill = nightTextColor; boids_vision_max.textFill = nightTextColor

			boids_distance_deplacement_label.textFill = nightTextColor
			boids_distance_deplacement_display.textFill = nightTextColor
			boids_distance_deplacement_min.textFill = nightTextColor
			boids_distance_deplacement_max.textFill = nightTextColor
			
			boid_group.textFill = Color.rgb(191, 191, 191, 0.7)
			boid_vitesse.textFill = Color.rgb(191, 191, 191, 0.7)
			boid_group_vitesse.textFill = Color.rgb(191, 191, 191, 0.7)
			boid_masse.textFill = Color.rgb(191, 191, 191, 0.7)
			boid_angle.textFill = Color.rgb(191, 191, 191, 0.7)
			boid_distance.textFill = Color.rgb(191, 191, 191, 0.7)
			boid_new_vitesse.textFill = Color.rgb(191, 191, 191, 0.7)
			toggle_night_mode.textFill = Color.rgb(191, 191, 191, 0.3)
			toggle_perception.textFill = Color.rgb(191, 191, 191, 0.3)
			hide_infos.textFill = Color.rgb(191, 191, 191, 0.3)
			start_button.textFill = nightTextColor
		}
	}
	
	@FXML protected def togglePerception() : void {
		if(togglePerception) {
			togglePerception = false
			perception_indicator.fill = Color.TRANSPARENT
		} else {
			togglePerception = true
			perception_indicator.fill = Color.rgb(0, 204, 99)
		}
	}
	
	@FXML protected def toggleButtonGlow() : void {	
		if(nightMode)
			toggle_night_mode.textFill = Color.rgb(235, 221, 26)
		else
			toggle_night_mode.textFill = Color.rgb(0, 0, 0)
		var glowEffect = new Glow()
		glowEffect.level = 0.8
		toggle_night_mode.effect = glowEffect
	}
	
	@FXML protected def toggleButtonReset() : void {
		if(launched) {
			if (nightMode)
				toggle_night_mode.textFill = Color.rgb(191, 191, 191, 0.3)
			else
				toggle_night_mode.textFill = Color.rgb(0, 0, 0, 0.3)
		} else {
			if (nightMode)
				toggle_night_mode.textFill = Color.rgb(191, 191, 191)
			else
				toggle_night_mode.textFill = Color.rgb(0, 0, 0)
		}
		toggle_night_mode.effect = null
	}

	@FXML protected def startButtonGlow() : void {
		if (nightMode)
			start_button.textFill = Color.rgb(235, 221, 26)
		else
			start_button.textFill = Color.rgb(0, 0, 0)
		var glowEffect = new Glow()
		glowEffect.level = 0.8
		start_button.effect = glowEffect
	}

	@FXML protected def startButtonReset() : void {
		if (nightMode)
			start_button.textFill = Color.rgb(191, 191, 191)
		else
			start_button.textFill = Color.rgb(0, 0, 0)
		start_button.effect = null
	}
	
	@FXML protected def perceptionButtonGlow() : void {
		if (nightMode)
			toggle_perception.textFill = Color.rgb(235, 221, 26)
		else
			toggle_perception.textFill = Color.rgb(0, 0, 0)
		var glowEffect = new Glow()
		glowEffect.level = 0.8
		toggle_perception.effect = glowEffect
	}
	
	@FXML protected def perceptionButtonReset() : void {
		if (nightMode)
			toggle_perception.textFill = Color.rgb(191, 191, 191, 0.3)
		else
			toggle_perception.textFill = Color.rgb(0, 0, 0, 0.3)
		toggle_perception.effect = null
	}
	
	@FXML protected def infosButtonGlow() : void {
		if (nightMode)
			hide_infos.textFill = Color.rgb(235, 221, 26)
		else
			hide_infos.textFill = Color.rgb(0, 0, 0)
		var glowEffect = new Glow()
		glowEffect.level = 0.8
		hide_infos.effect = glowEffect
	}
	
	@FXML protected def infosButtonReset() : void {
		if (nightMode)
			hide_infos.textFill = Color.rgb(191, 191, 191, 0.3)
		else
			hide_infos.textFill = Color.rgb(0, 0, 0, 0.3)
		hide_infos.effect = null
	}
	
	@FXML protected def incrementBoidsPopulationGlow() : void {
		if (nightMode) {
			boids_population_increment_circle.stroke = Color.rgb(235, 221, 26)
			increment_boids_population.textFill = Color.rgb(235, 221, 26)
		} else {
			boids_population_increment_circle.stroke = Color.rgb(0, 0, 0)
			increment_boids_population.textFill = Color.rgb(0, 0, 0)	
		}
		var glowEffect = new Glow()
		glowEffect.level = 0.8
		boids_population_increment_circle.effect = glowEffect
	}
	
	@FXML protected def incrementBoidsPopulationReset() : void {
		if (nightMode) {
			boids_population_increment_circle.stroke = Color.rgb(191, 191, 191)
			increment_boids_population.textFill = Color.rgb(191, 191, 191)
		}
		else {
			boids_population_increment_circle.stroke = Color.rgb(0, 0, 0, 0.3)
			increment_boids_population.textFill = Color.rgb(0, 0, 0)
		}
		boids_population_increment_circle.effect = null
		increment_boids_population.effect = null
	}
	
	@FXML protected def decrementBoidsPopulationGlow() : void {
		if (nightMode) {
			boids_population_decrement_circle.stroke = Color.rgb(235, 221, 26)
			decrement_boids_population.textFill = Color.rgb(235, 221, 26)
		} else {
			boids_population_decrement_circle.stroke = Color.rgb(0, 0, 0)
			decrement_boids_population.textFill = Color.rgb(0, 0, 0)
		}
		var glowEffect = new Glow()
		glowEffect.level = 0.8
		boids_population_decrement_circle.effect = glowEffect
	}	
	
	@FXML protected def decrementBoidsPopulationReset() : void {
		if (nightMode) {
			boids_population_decrement_circle.stroke = Color.rgb(191, 191, 191)
			decrement_boids_population.textFill = Color.rgb(191, 191, 191)
		} else {
			boids_population_decrement_circle.stroke = Color.rgb(0, 0, 0, 0.3)
			increment_boids_population.textFill = Color.rgb(0, 0, 0)
		}
		boids_population_decrement_circle.effect = null
		decrement_boids_population.effect = null
	}
	
	@FXML protected def boidsPopulationGlow() : void {
		if (nightMode) {
			boids_population_input.style = '-fx-text-fill: rgb(235, 221, 26); -fx-background-color: transparent'
		} else {
			boids_population_input.style = '-fx-text-fill: rgb(0, 0, 0); -fx-background-color: transparent'
		}
		boids_population_line.strokeWidth = 3
		var glowEffect = new Glow()
		glowEffect.level = 0.8
		boids_population_input.effect = glowEffect
	}
	
	@FXML protected def boidsPopulationReset() : void {
		if (nightMode) {
			boids_population_input.style = '-fx-text-fill: rgb(191, 191, 191); -fx-background-color: transparent'
		} else {
			boids_population_input.style = '-fx-text-fill: rgb(0, 0, 0); -fx-background-color: transparent'
		}
		boids_population_line.strokeWidth = 1
		boids_population_input.effect = null
	}
	
	def toggleUIState() : void {
		if(start_button.disable == true) start_button.disable = false else start_button.disable = true
		if(boids_quantity_input.disable == true) boids_quantity_input.disable = false else boids_quantity_input.disable = true
		if(map_selection_input.disable == true) map_selection_input.disable = false else map_selection_input.disable = true
		if(boids_population_input.disable == true) boids_population_input.disable = false else boids_population_input.disable = true
		if(boids_vision_input.disable == true) boids_vision_input.disable = false else boids_vision_input.disable = true

		if(boids_distance_deplacement_input.disable == true) boids_distance_deplacement_input.disable = false else boids_distance_deplacement_input.disable = true
		// if(toggle_night_mode.disable == true)  toggle_night_mode.disable = false else toggle_night_mode.disable = true
	}
	
	def toggleMenuUIVisibility() : void {
		if(UI_pane.visible) UI_pane.visible = false else UI_pane.visible = true
	}
	
	def toggleSimuUIVisibility() : void {
		if(!toggle_perception.visible) toggle_perception.visible = true else toggle_perception.visible = false
		if(!perception_indicator.visible) perception_indicator.visible = true else perception_indicator.visible = false
	}
	
	@FXML def pause() : void {
		System.out.println("PAUSE DEMANDEE")
		pause_button.visible = false
		resume_button.visible = true
		emitToAgents(new Pause)
	}
	
	@FXML def resume() : void {
		pause_button.visible = true
		resume_button.visible = false
		emitToAgents(new Resume)
	}
	
	def hideInfosVisibility() : void { // TODO Renae en disable
		this.resetTexts()
		boids_infos_pane.visible = false
		boids_infos_pane.disable = true
		/*boid_group.visible = false
		boid_vitesse.visible = false
		boid_group_vitesse.visible = false
		boid_masse.visible = false
		boid_angle.visible = false
		boid_distance.visible = false
		boid_new_vitesse.visible = false
		hide_infos.visible = false*/
	}
	
	def resetTexts() : void {
		boid_group.text = ''
		boid_vitesse.text = ''
		boid_group_vitesse.text = ''
		boid_masse.text = ''
		boid_angle.text = ''
		boid_distance.text = ''
		boid_new_vitesse.text = ''
	}

	def showInfosVisibility() : void { // TODO Rename en disable
		boids_infos_pane.visible = true
		boids_infos_pane.disable = false
		/*boid_group.visible = true
		boid_vitesse.visible = true
		boid_group_vitesse.visible = true
		boid_masse.visible = true
		boid_angle.visible = true
		boid_distance.visible = true
		boid_new_vitesse.visible = true
		hide_infos.visible = true*/
	}
	
	def outputQuality(output : String) : Boolean {
		var outputQuality : Boolean = false
		try {
			Integer.parseInt(boids_population_input.text)
			outputQuality = true
		} catch (e : NumberFormatException) {
			System.out.println('Invalid number of populations!')
		}
		return outputQuality
	}
	
	@FXML protected def changeFocus() : void {
		main_pane.requestFocus()
	}
	
	/* BOIDS QUANTITY GLOWING EFFECT */
	
	@FXML protected def boidsQuantityMinGlow() : void {
		if (nightMode)
			boids_quantity_min.textFill = Color.rgb(235, 221, 26)
		else
			boids_quantity_min.textFill = Color.rgb(0, 0, 0)
		var glowEffect = new Glow()
		glowEffect.level = 0.8
		boids_quantity_min.effect = glowEffect
	}
	
	@FXML protected def boidsQuantityMaxGlow() : void {
		if (nightMode)
			boids_quantity_max.textFill = Color.rgb(235, 221, 26)
		else
			boids_quantity_max.textFill = Color.rgb(0, 0, 0)
		var glowEffect = new Glow()
		glowEffect.level = 0.8
		boids_quantity_max.effect = glowEffect
	}
	
	@FXML protected def boidsQuantityMinReset() : void {
		if (nightMode)
			boids_quantity_min.textFill = Color.rgb(191, 191, 191)
		else
			boids_quantity_min.textFill = Color.rgb(0, 0, 0)
		boids_quantity_min.effect = null
	}
	
	@FXML protected def boidsQuantityMaxReset() : void {
		if (nightMode)
			boids_quantity_max.textFill = Color.rgb(191, 191, 191)
		else
			boids_quantity_max.textFill = Color.rgb(0, 0, 0)
		boids_quantity_max.effect = null
	}
	
	/* BOIDS PERCEPTION ANGLE GLOWING EFFECT */
	 
	@FXML protected def boidsVisionMinGlow() : void {
		if (nightMode)
			boids_vision_min.textFill = Color.rgb(235, 221, 26)
		else
			boids_vision_min.textFill = Color.rgb(0, 0, 0)
		var glowEffect = new Glow()
		glowEffect.level = 0.8
		boids_vision_min.effect = glowEffect
	}

	@FXML protected def boidsVisionMaxGlow() : void {
		if (nightMode)
			boids_vision_max.textFill = Color.rgb(235, 221, 26)
		else
			boids_vision_max.textFill = Color.rgb(0, 0, 0)
		var glowEffect = new Glow()
		glowEffect.level = 0.8
		boids_vision_max.effect = glowEffect
	}

	@FXML protected def boidsVisionMinReset() : void {
		if (nightMode)
			boids_vision_min.textFill = Color.rgb(191, 191, 191)
		else
			boids_vision_min.textFill = Color.rgb(0, 0, 0)
		boids_vision_min.effect = null
	}

	@FXML protected def boidsVisionMaxReset() : void {
		if (nightMode)
			boids_vision_max.textFill = Color.rgb(191, 191, 191)
		else
			boids_vision_max.textFill = Color.rgb(0, 0, 0)
		boids_vision_max.effect = null
	}
	
	/* BOIDS DISTANCE PERCEPTION GLOWING EFFECT */
	
	@FXML protected def boidsDistanceVisionMinGlow() : void {
		if (nightMode)
			boids_distance_deplacement_min.textFill = Color.rgb(235, 221, 26)
		else
			boids_distance_deplacement_min.textFill = Color.rgb(0, 0, 0)
		var glowEffect = new Glow()
		glowEffect.level = 0.8
		boids_distance_deplacement_min.effect = glowEffect
	}

	@FXML protected def boidsDistanceVisionMaxGlow() : void {
		if (nightMode)
			boids_distance_deplacement_max.textFill = Color.rgb(235, 221, 26)
		else
			boids_distance_deplacement_max.textFill = Color.rgb(0, 0, 0)
		var glowEffect = new Glow()
		glowEffect.level = 0.8
		boids_distance_deplacement_max.effect = glowEffect
	}

	@FXML protected def boidsDistanceVisionMinReset() : void {
		if (nightMode)
			boids_distance_deplacement_min.textFill = Color.rgb(191, 191, 191)
		else
			boids_distance_deplacement_min.textFill = Color.rgb(0, 0, 0)
		boids_distance_deplacement_min.effect = null
	}

	@FXML protected def boidsDistanceVisionMaxReset() : void {
		if (nightMode)
			boids_distance_deplacement_max.textFill = Color.rgb(191, 191, 191)
		else
			boids_distance_deplacement_max.textFill = Color.rgb(0, 0, 0)
		boids_distance_deplacement_max.effect = null
	}
	
	/* MAP GLOWING EFFECT */
	
	@FXML protected def mapMinGlow() : void {
		if (nightMode)
			map_min.textFill = Color.rgb(235, 221, 26)
		else
			map_min.textFill = Color.rgb(0, 0, 0)
		var glowEffect = new Glow()
		glowEffect.level = 0.8
		map_min.effect = glowEffect
	}

	@FXML protected def mapMaxGlow() : void {
		if (nightMode)
			map_max.textFill = Color.rgb(235, 221, 26)
		else
			map_max.textFill = Color.rgb(0, 0, 0)
		var glowEffect = new Glow()
		glowEffect.level = 0.8
		map_max.effect = glowEffect
	}

	@FXML protected def mapMinReset() : void {
		if (nightMode)
			map_min.textFill = Color.rgb(191, 191, 191)
		else
			map_min.textFill = Color.rgb(0, 0, 0)
		map_min.effect = null
	}

	@FXML protected def mapMaxReset() : void {
		if (nightMode)
			map_max.textFill = Color.rgb(191, 191, 191)
		else
			map_max.textFill = Color.rgb(0, 0, 0)
		map_max.effect = null
	}
	
	/* MAX/MIN values fast setters */
	
	@FXML protected def boidsQuantitySetToMin() : void {
		boids_quantity_input.value = Integer.parseInt(boids_quantity_min.text)
		boids_quantity_display.text = boids_quantity_min.text
	}
	
	@FXML protected def boidsQuantitySetToMax() : void {
		boids_quantity_input.value = Integer.parseInt(boids_quantity_max.text)
		boids_quantity_display.text = boids_quantity_max.text
	}

	@FXML protected def boidsVisionSetToMin() : void {
		boids_vision_input.value = Integer.parseInt(boids_vision_min.text)
		boids_vision_display.text = boids_vision_min.text
	}

	@FXML protected def boidsVisionSetToMax() : void {
		boids_vision_input.value = Integer.parseInt(boids_vision_max.text)
		boids_vision_display.text = boids_vision_max.text
	}

	@FXML protected def boidsDistanceVisionSetToMin() : void {
		boids_distance_deplacement_input.value = Integer.parseInt(boids_distance_deplacement_min.text)
		boids_distance_deplacement_display.text = boids_distance_deplacement_min.text
	}

	@FXML protected def boidsDistanceVisionSetToMax() : void {
		boids_distance_deplacement_input.value = Integer.parseInt(boids_distance_deplacement_max.text)
		boids_distance_deplacement_display.text = boids_distance_deplacement_max.text
	}

	@FXML protected def mapSetToMin() : void {
		map_selection_input.value = Integer.parseInt(map_min.text)
		map_selection_display.text = map_min.text
	}

	@FXML protected def mapSetToMax() : void {
		map_selection_input.value = Integer.parseInt(map_max.text)
		map_selection_display.text = map_max.text
	}
}
