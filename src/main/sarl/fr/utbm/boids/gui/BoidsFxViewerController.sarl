package fr.utbm.boids.gui

import fr.utbm.boids.gui.fx.FxViewerController
import javafx.fxml.FXML
import fr.utbm.boids.events.ConfigureSimulation
import javafx.scene.control.Label
import javafx.scene.control.ScrollBar
import javafx.scene.control.Button
import javafx.scene.Group
import javafx.scene.layout.Pane
import javafx.application.Platform
import javafx.scene.shape.Polygon
import fr.utbm.boids.util.Coordinates
import fr.utbm.boids.util.LineTool
import com.google.common.util.concurrent.AtomicDouble
import java.util.ArrayList
import java.util.List
import fr.utbm.boids.environment.Obstacle
import javafx.animation.PauseTransition
import fr.utbm.boids.BoidBody
import java.util.Collection
import javafx.scene.shape.Circle
import java.util.UUID
import javafx.scene.paint.Color
import javafx.scene.shape.Shape
import javafx.geometry.Point2D
import fr.utbm.boids.Configuration

import static extension javafx.util.Duration.*


class BoidsFxViewerController extends FxViewerController implements Configuration  {

	var launched = false
	var mapCreated = false

	@FXML var main_pane : Pane
	@FXML var boids_group : Group // Groupe contenant les boids
	@FXML var UI_pane : Pane // Pane contenant l'UI
	@FXML var obstacle_group : Group // Groupe contenant les obstacles
	
	@FXML var start_button : Button

	// Titres
	@FXML var boids_quantity_label : Label
	@FXML var map_selection_label : Label
	@FXML var boids_population_label : Label
	@FXML var boids_vision_label : Label

	// Sliders
	@FXML var boids_quantity_input : ScrollBar
	@FXML var map_selection_input : ScrollBar
	@FXML var boids_population_input : ScrollBar
	@FXML var boids_vision_input : ScrollBar

	// Valeurs
	@FXML var boids_quantity_display : Label
	@FXML var map_selection_display : Label
	@FXML var boids_population_display : Label
	@FXML var boids_vision_display : Label

	var polygons : List<Polygon>
	var polygonsCoordinates : List<List<Coordinates>>
	var obstacles : List<Obstacle>
	var obstacleShells : List<Obstacle>

	def getBoidsQuantity() : int {
		boids_quantity_input.value as int
	}
	
	def getMapSelection() : int {
		map_selection_input.value as int
	}
	
	def getBoidsPopulation() : int {
		boids_population_input.value as int
	}
	
	def getBoidsVision() : int {
		boids_vision_input.value as int
	}
	
	def getMapWidth() : int {
		main_pane.width as int
	}
	
	def getMapHeight() : int {
		main_pane.height as int
	}
	
	def getObstacles() : List<Obstacle> {
		obstacles
	}
 
	@FXML protected def startSimu() : void {
		var ^event = new ConfigureSimulation(this.mapSelection, this.boidsQuantity, this.boidsPopulation, this.boidsVision)
		if (!launched) {
			startAgentApplication() [
				emitToAgents(^event)
			]
			launched = true
			mapCreated = false
			toggleUIState()
			toggleUIVisibility()			
		} else {
			emitToAgents(^event)
		}
	}
	
	def buildMap(map : int) : List<Obstacle> {

		if(map == 1) {
			return new ArrayList()
		}
		else if (map == 2) {
			this.polygons = new ArrayList()
			this.polygonsCoordinates = new ArrayList()
			this.obstacles = new ArrayList()
			this.polygons.add(new Polygon(250.0, 200.0, 365.0, 250.0, 400.0, 300.0, 325.0, 400.0, 205.0, 225.0))
			this.polygons.add(new Polygon(605.0, 80.0, 675.0, 65.0, 680.0, 125.0, 650.0, 220.0, 630.0, 250.0, 660.0, 130.0,
					665.0, 75.0, 615.0, 95.0, 560.0, 240.0, 560.0, 205.0, 605.0, 80.0))
			this.polygons.add(new Polygon(450.0, 450.0, 575.0, 500.0, 575.0, 420.0, 700.0, 500.0, 590.0, 450.0, 590.0, 520.0))
			this.polygons.forEach[p : Polygon |
				this.polygonsCoordinates.add(this.generateCoordinates(p))
				p.setFill(Color.GRAY)
				p.setStroke(Color.TRANSPARENT)
				p.setStrokeWidth(20)
			]

			var command = new Runnable() {
				@Override
				def run() {
					polygons.forEach [ p : Polygon |
						obstacle_group.getChildren().add(0, p)
					]
					/*System.out.println('LE TEST')
					var testcircle = new Circle(395, 310, 1)
					//System.out.println(polygons.get(0).contains(new Point2D(testcircle.centerX, testcircle.centerY)))
					obstacle_group.getChildren().add(0, testcircle)*/
				}
		};

			if (Platform.isFxApplicationThread()) {
				command.run();
				this.generateObstacles()
				// this.obstacles.forEach[o : Obstacle|System.out.println(o.toString())]
				return this.obstacles
			} else {
				Platform.runLater(command);
				this.generateObstacles()
				// this.obstacles.forEach[o : Obstacle|System.out.println(o.toString())]
				return this.obstacles
			}
		}
	}
	
	def generateCoordinates(p : Polygon) : List<Coordinates> {
		var abscissa : AtomicDouble = new AtomicDouble();
		var coordinates : List<Coordinates> = new ArrayList()
		p.getPoints.forEach [ ordered : Double, index : int |
			if (index % 2 == 0) {
				abscissa.set(ordered)
			} else {
				coordinates.add(new Coordinates(abscissa.get(), ordered.doubleValue()))
			}
		]
		return coordinates
	}
	
	def generateObstacles() : void {
		this.polygonsCoordinates.forEach [p : List<Coordinates>, currentItem : int |
			var lines : List<LineTool> = new ArrayList()
			p.forEach[c : Coordinates, index : int |
				if(index != 0) {
					var line : LineTool = new LineTool(p.get(index - 1), c)
					line.computeLineEquation()
					lines.add(line)
				}
			]
			var line : LineTool = new LineTool(p.last, p.get(0))
			line.computeLineEquation()
			lines.add(line)
			this.obstacles.add(new Obstacle(lines, this.polygons.get(currentItem)))
		]
		
	}
	
	def updateGraphics(list: Collection<BoidBody>) : void {
		var command = new Runnable() {
			@Override
			def run() {
				boids_group.getChildren().clear()
				// TODO reduire taille de la partie d'affichage pour les boids + mettre une couleur en fonction du groupe + remplacer cercle par triangle
				for (boid : list){
					/*var cercle = new Circle()
					//cercle.setCenterX(boid.position.x + getMapWidth / 2);
					//cercle.setCenterY(boid.position.y + getMapHeight/2); 
					cercle.setCenterX(boid.position.x)
					cercle.setCenterY(boid.position.y)
					cercle.setRadius(10.0f);
					cercle.fill = COLOR_FAMILY.get(boid.groupe)
					boids_group.getChildren().add(0, cercle)*/
					var boidElement : Polygon = new Polygon(boid.position.x, boid.position.y - 7.5, boid.position.x + 5, boid.position.y + 7.5, boid.position.x - 5, boid.position.y + 7.5)
					boidElement.rotate = Math.toDegrees(Math.atan(boid.vitesse.x / boid.vitesse.y))
					boidElement.setFill(COLOR_FAMILY.get(boid.groupe))
					boids_group.getChildren().add(0, boidElement)
				}
			}
		}
		
		if (Platform.isFxApplicationThread()) {
			command.run();
		} else {
			Platform.runLater(command);
		}	
	}

	@FXML protected def actionBoidsQuantityDisplay() : void {
		boids_quantity_input.valueProperty().addListener [
			boids_quantity_display.setText(String.format("%.0f", boids_quantity_input.getValue()));
		];
	}

	@FXML protected def actionMapSelectionDisplay() : void {
		map_selection_input.valueProperty().addListener [
			map_selection_display.setText(String.format("%.0f", map_selection_input.getValue()));
		];
	}

	@FXML protected def actionPopulationDisplay() : void {
		boids_population_input.valueProperty().addListener [
			boids_population_display.setText(String.format("%.0f", boids_population_input.getValue()));
		];
	}

	@FXML protected def actionBoidsVisionDisplay() : void {
		boids_vision_input.valueProperty().addListener [
			boids_vision_display.setText(String.format("%.0f", boids_vision_input.getValue()));
		];
	}
	
	def toggleUIState() : void {
		if(start_button.disable == true) start_button.disable = false else start_button.disable = true
		if(boids_quantity_input.disable == true) boids_quantity_input.disable = false else boids_quantity_input.disable = true
		if(map_selection_input.disable == true) map_selection_input.disable = false else map_selection_input.disable = true
		if(boids_population_input.disable == true) boids_population_input.disable = false else boids_population_input.disable = true
		if(boids_vision_input.disable == true) boids_vision_input.disable = false else boids_vision_input.disable = true
	}
	
	def toggleUIVisibility() : void {
		if(UI_pane.visible) UI_pane.visible = false else UI_pane.visible = true
	}
	
}
