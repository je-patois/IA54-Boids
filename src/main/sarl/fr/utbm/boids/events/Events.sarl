package fr.utbm.boids.events

import java.util.Collection
import fr.utbm.boids.agents.Boid
import fr.utbm.boids.Vector
import java.util.UUID
import fr.utbm.boids.BoidBody
import java.util.Map
import fr.utbm.boids.environment.Obstacle
import java.util.List

/**
 * Transfert des paramètres utilisateurs au BootAgent
 * @param mapSelection - Map choisie
 * @param boidsQuantity - Nombre de boids par population
 * @param boidsPopulation - Nombre de populations
 * @param boidsVision - Radius de perception des boids
 */
event ConfigureSimulation {
	val mapSelection : int
	val boidsQuantity : int
	val boidsPopulation : int
	val boidsVision : int
	
	new(mS : int, bQ : int, bP : int, bV : int) {
		mapSelection = mS
		boidsQuantity = bQ
		boidsPopulation = bP
		boidsVision = bV
	}
}

/** 
 * Un IsStarted avec le body en plus
 * @param body - Transfert du `BoidBody` 
 */
event BoidInitialized {
	var body : BoidBody
	var type : String

	new(body : BoidBody, typeEntity : String) {
		this.body = body
		this.type = typeEntity
	}
}

/**
 * Evenement ordonnant à l'agent GUI de débuter sa fonction
 */
event MakeTheFiestaBegin

/**
 * Formule une demande de déplacement auprès d'un boid
 * @param otherBoids - Liste des autres boids, permettant au boid de décider de son placement
 */
event DemandeDeplacement {

	/*var otherBoids : Collection<BoidBody>*/
	var otherBoids : Map<UUID, BoidBody>

	/*new (pos : Vector, otherBoids : Collection<BoidBody>) {
		this.otherBoids = otherBoids
	}

	new (x : int, y : int, otherBoids : Collection<BoidBody>) {
		this.otherBoids = otherBoids
	}*/
	
	//provisoire
	new() {
	}

	new (otherBoids : Map<UUID, BoidBody>) {
		this.otherBoids = otherBoids
	}
}

/**
 * Evenement lancé lorsqu'un boid désire se déplacer. Il transfert ici la prochaine position qu'il veut, pour que l'environnement puisse décider de si il s'agit d'une position viable ou non
 * @param position - Nouvelle position du boid
 * @param newVitesse - Nouveau vecteur vitesse du boid
 */
event ResultatDeplacement {
	var position : Vector
	var newSpeed : Vector

	new (pos : Vector, vit : Vector) {
		this.position = pos
		this.newSpeed = vit
	}

	/*new (x : int, y : int) {
		this.position.setXY(x, y)
	}*/
}

/**
 * Valide le déplacement d'un boid
 */
event ValidationDeplacement{
	var position : Vector
	
	new (pos : Vector){
		this.position = pos
	}
}

/**
 * Débute la simulation
 */
event StartingSimulation
 
/**
 * Initialise les positions intiales des boids
 * @param height - Position du boid en y
 * @param width - Position du boid en x
 * @param obstacles - Liste des obstacles avec les données relatives à leur traitement
 */
event StartPosition {
	var height : int
	var width : int
	var obstacles : List<Obstacle>

	new (h : int, l : int, obstacles : List<Obstacle>) {
		this.height = h
		this.width = l
		this.obstacles = obstacles
	}
}

/**
 * Envoi des données relatives aux boids
 * @parameter lesBoids - Données relatives aux boids
 */
event SendDataBoids {
	var lesBoids : Collection<Boid>
	
	new(boids : Collection<Boid>){
		this.lesBoids = boids
	}
}

/**
 * Demande au boid d'initialiser son BoidBody 
 * @parameter body - BoidBody du boid
 */
event InitBoidBody{
	var body : BoidBody
	
	new (body : BoidBody){
		this.body = body
	}
}

/**
 * Evenement déclenché lorsqu'un BoidBody est correctement initialisé 
 */
event BoidBodyInitialized

/** 
 * Evenement déclenché lorsque le nombre d'agents `Boid` correspond au nombre de boids demandé
 */
event BoidsReady

/**
 * Demande au Time Manager de démarrer ses cycles
 * @param frequency - Fréquence de raffraichissement entre 2 cycles
 */
event TimeManagingStart {
	var frequency : long
	
	new(frequency : long) {
		this.frequency = frequency
	}
}

/**
 * Evenement déclenché lorsque les boids sont prêts 
 */
event BoidsSideReady

/**
 * Signalement du début d'un nouveau cycle
 */
event Cycle

/**
 * Pause la simulation 
 */
event Pause

/**
 * Reprend la simulation 
 */
event Resume

event BtnLaunch

event BtnShutdown